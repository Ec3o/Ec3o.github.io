import{_ as a,c as i,o as s,a1 as n}from"./chunks/framework.CJ8LAyNs.js";const m=JSON.parse('{"title":"Go语言中的包","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Go/Go基础/Go中的包.md","filePath":"articles/Go/Go基础/Go中的包.md"}'),e={name:"articles/Go/Go基础/Go中的包.md"},o=n(`<h1 id="go语言中的包" tabindex="-1">Go语言中的包 <a class="header-anchor" href="#go语言中的包" aria-label="Permalink to &quot;Go语言中的包&quot;">​</a></h1><p><code>Go</code>语言中的包(Package)是<code>Go</code>语言组织代码的一种独特形式，它有助于代码的封装、复用和管理.</p><h2 id="go语言中包的概念" tabindex="-1">Go语言中包的概念 <a class="header-anchor" href="#go语言中包的概念" aria-label="Permalink to &quot;Go语言中包的概念&quot;">​</a></h2><p><code>Go</code>语言使用包来组织源代码的，并实现命名空间的管理，任何一个<code>Go</code>语言程序必须属于一个包，即每个<code>go</code>程序的开头要写上<code>package &lt;pkg_name&gt;</code>。</p><p><code>Go</code>语言包一般要满足如下三个条件：</p><ul><li><em>同一个目录下的<strong>同级</strong>的所有<code>go</code>文件应该属于一个包；</em></li><li>包的名称可以跟目录不同名，不过建议同名；</li><li>一个<code>Go</code>语言程序有且只有一个<code>main</code>函数，他是<code>Go</code>语言程序的入口函数，且必须属于<code>main</code>包，没有或者多于一个进行<code>Go</code>程序编译时都会报错；</li></ul><h2 id="包的引用" tabindex="-1">包的引用 <a class="header-anchor" href="#包的引用" aria-label="Permalink to &quot;包的引用&quot;">​</a></h2><h3 id="关于gopath" tabindex="-1">关于<code>GOPATH</code>... <a class="header-anchor" href="#关于gopath" aria-label="Permalink to &quot;关于\`GOPATH\`...&quot;">​</a></h3><p><code>GOPATH</code>是GO语言使用的一个环境变量，使用绝对路径提供项目的工作目录，适合处理大量 Go语言源码、多个包组合而成的复杂工程。实际使用中，可以先通过命令<code>go env</code>来查看一下当前的<code>GOPATH</code>值，然后再决定是不是需要重新设置。</p><p><img src="https://ec3o.oss-cn-hangzhou.aliyuncs.com/img/20240410174820.png" alt=""></p><h3 id="包引用格式" tabindex="-1">包引用格式 <a class="header-anchor" href="#包引用格式" aria-label="Permalink to &quot;包引用格式&quot;">​</a></h3><p>Go包的引入格式常见的有四种，下面以引用<code>fmt</code>包为例说明：</p><ul><li>标准引用 <code>import fmt</code></li><li>设置别名引用 <code>import format_go fmt</code> <em>省略方式的引用 <code>import . fmt</code>，这种引用相当于把包<code>fmt</code>的命名空间合并到当前程序的命名空间了，因此可以直接引用，不用在加上前缀<code>fmt.</code></em></li><li>仅执行包的初始化函数 <code>import _ fmt</code></li></ul><p>另外，当一个<code>Go</code>程序需要导入多个包时，可以使用单行导入或者多行导入，如下分别列出两种导入形式：</p><ul><li>单行导入</li></ul><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import &quot;package1&quot;</span></span>
<span class="line"><span>import &quot;package2\`</span></span></code></pre></div><ul><li>多行导入</li></ul><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">package01</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">package02</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>另外，导入的包必须要被使用，否则程序编译时也会报错。</p><h3 id="包引用初始化流程" tabindex="-1">包引用初始化流程 <a class="header-anchor" href="#包引用初始化流程" aria-label="Permalink to &quot;包引用初始化流程&quot;">​</a></h3><p>假设一个<code>go</code>语言程序的引入包的顺序是：<code>main-&gt; 包A -&gt; 包B -&gt;包C</code>，且包A、B、C均实现了<code>init()</code>函数，那么整个初始化流程顺序则为：<code>C.init -&gt; B.init -&gt; A.init -&gt; main-&gt; 包A -&gt; 包B -&gt; 包C</code>。</p><h3 id="包中标识符的导出" tabindex="-1">包中标识符的导出 <a class="header-anchor" href="#包中标识符的导出" aria-label="Permalink to &quot;包中标识符的导出&quot;">​</a></h3><p>如果一个包要引用另一个包的标识符(比如结构体、变量、常量、函数等)，那么首先必须要将其导出，具体做法就是在<strong>定义这些标识符的时候保证首字母大写</strong>(首字母小写的标识符只能限制在包内引用，有点类似使用Java中使用<code>Public</code> <code>Private</code>等来控制成员变量在不同代码中的可访问权限)。另外在被导出的的结构体或者接口中，<strong>首字母大写的字段和方法才能被包外访问</strong>。</p><h3 id="包的作用域" tabindex="-1">包的作用域 <a class="header-anchor" href="#包的作用域" aria-label="Permalink to &quot;包的作用域&quot;">​</a></h3><ul><li>包内部的标识符（如变量、常量、类型、函数等）如果首字母大写，则可以被外部包访问，称为<strong>导出</strong>（Exported）或<strong>公开</strong>的。</li><li>如果标识符首字母小写，则仅在同一个包内可见，即为包私有的。</li></ul><h2 id="主包和可执行文件" tabindex="-1">主包和可执行文件 <a class="header-anchor" href="#主包和可执行文件" aria-label="Permalink to &quot;主包和可执行文件&quot;">​</a></h2><ul><li>每个Go程序都有一个名为<code>main</code>的包，这是程序的入口点。<code>main</code>包包含<code>main()</code>函数，程序从这里开始执行。</li><li>只有<code>main</code>包可以编译成可执行文件。</li></ul><h2 id="init函数和main函数" tabindex="-1">Init函数和main函数 <a class="header-anchor" href="#init函数和main函数" aria-label="Permalink to &quot;Init函数和main函数&quot;">​</a></h2><h3 id="init函数" tabindex="-1">init函数 <a class="header-anchor" href="#init函数" aria-label="Permalink to &quot;init函数&quot;">​</a></h3><p>go语言中<code>init</code>函数用于包<code>(package)</code>的初始化，该函数是go语言的一个重要特性。</p><p>有下面的特征：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    1 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    2 每个包可以拥有多个init函数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    3 包的每个源文件也可以拥有多个init函数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    4 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    5 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    6 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</span></span></code></pre></div><h3 id="main函数" tabindex="-1">main函数 <a class="header-anchor" href="#main函数" aria-label="Permalink to &quot;main函数&quot;">​</a></h3><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Go语言程序的默认入口函数</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(主函数)：</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    函数体用｛｝一对括号包裹。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //函数体</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h3 id="init函数和main函数的异同" tabindex="-1">init函数和main函数的异同 <a class="header-anchor" href="#init函数和main函数的异同" aria-label="Permalink to &quot;init函数和main函数的异同&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    相同点：</span></span>
<span class="line"><span>        两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。</span></span>
<span class="line"><span>    不同点：</span></span>
<span class="line"><span>        init可以应用于任意包中，且可以重复定义多个。</span></span>
<span class="line"><span>        main函数只能用于main包中，且只能定义一个。</span></span></code></pre></div><p>两个函数的执行顺序：</p><p>对同一个go文件的<code>init()</code>调用顺序是从上到下的。</p><p>对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的<code>init()</code>函数。</p><p>对于不同的<code>package</code>，如果不相互依赖的话，按照main包中&quot;先<code>import</code>的后调用&quot;的顺序调用其包中的<code>init()</code>，如果<code>package</code>存在依赖，则先调用最早被依赖的<code>package</code>中的<code>init()</code>，最后调用<code>main</code>函数。</p><p>如果<code>init</code>函数中使用了<code>println()</code>或者<code>print()</code>你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</p>`,41),t=[o];function p(l,c,d,h,r,g){return s(),i("div",null,t)}const u=a(e,[["render",p]]);export{m as __pageData,u as default};
